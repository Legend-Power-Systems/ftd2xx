# flake8: noqa
# generated by 'xml2py'
# flags '-c -d -k defst -l ftd2xx.dll -o _ftd2xx.py -m ctypes.wintypes ftd2xx.xml'
import os
from ctypes import (
    CFUNCTYPE,
    POINTER,
    Structure,
    WinDLL,
    c_char,
    c_char_p,
    c_uint,
    c_int,
    c_ubyte,
    c_ulong,
    c_ulonglong,
    c_void_p,
)
from ctypes.wintypes import (
    BOOL,
    BYTE,
    DWORD,
    HANDLE,
    LPCSTR,
    ULONG,
    WORD,
    USHORT,
    PCHAR,
    LPWORD,
    LPLONG,
    PULONG,
    LPVOID,
    LONG,
)


STRING = c_char_p
UCHAR = c_ubyte
CHAR = c_char
UINT = c_uint
PUCHAR = POINTER(c_ubyte)
PVOID = c_void_p
LPTSTR = STRING
LPDWORD = POINTER(DWORD)
VOID: None = None
ULONGLONG = c_ulonglong
# WinTypes.h 38


class _OVERLAPPED(Structure):
    _fields_ = [
        # WinTypes.h 38
        ("Internal", DWORD),
        ("InternalHigh", DWORD),
        ("Offset", DWORD),
        ("OffsetHigh", DWORD),
        ("hEvent", HANDLE),
    ]


LPOVERLAPPED = POINTER(_OVERLAPPED)
OVERLAPPED = _OVERLAPPED
# WinTypes.h 46


class _SECURITY_ATTRIBUTES(Structure):
    _fields_ = [
        # WinTypes.h 46
        ("nLength", DWORD),
        ("lpSecurityDescriptor", LPVOID),
        ("bInheritHandle", BOOL),
    ]


LPSECURITY_ATTRIBUTES = POINTER(_SECURITY_ATTRIBUTES)
SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES
# WinTypes.h 52

_libraries = {}

# If you need non-standard DLL directory, set FTD2XX_DLL_DIR to absoluate path to dll
extra_dll_dir = os.environ.get("FTD2XX_DLL_DIR")
if extra_dll_dir:
    os.add_dll_directory(extra_dll_dir)
try:
    _libraries["ftd2xx.dll"] = WinDLL("ftd2xx64.dll")
except OSError:  # 32-bit, or 64-bit library with plain name
    try:
        _libraries["ftd2xx.dll"] = WinDLL("ftd2xx.dll")
    except OSError as e:
        if e.winerror == 126:
            error_message = (
                e.args[1] + "Unable to find D2XX DLL. "
                "Please make sure that the directory containing your DLL is in "
                "one (or both) environment variables: 'PATH', 'FTD2XX_DLL_DIR'. "
                "Also, you must use 'ftd2xx.dll' or 'ftd2xx64.dll' as the filename."
            )
            e.args = (e.args[0], error_message) + e.args[2:]
        raise e


FT_HANDLE = PVOID
FT_STATUS = ULONG

# values for unnamed enumeration
PFT_EVENT_HANDLER = CFUNCTYPE(None, c_ulong, c_ulong)
FT_DEVICE = ULONG

# values for unnamed enumeration
# ftd2xx.h 216
FT_Open = _libraries["ftd2xx.dll"].FT_Open
FT_Open.restype = FT_STATUS
# FT_Open(deviceNumber, pHandle)
FT_Open.argtypes = [c_int, POINTER(FT_HANDLE)]
FT_Open.__doc__ = """FT_STATUS FT_Open(int deviceNumber, FT_HANDLE * pHandle)
ftd2xx.h:216"""
# ftd2xx.h 223
FT_OpenEx = _libraries["ftd2xx.dll"].FT_OpenEx
FT_OpenEx.restype = FT_STATUS
# FT_OpenEx(pArg1, Flags, pHandle)
FT_OpenEx.argtypes = [PVOID, DWORD, POINTER(FT_HANDLE)]
FT_OpenEx.__doc__ = """FT_STATUS FT_OpenEx(PVOID pArg1, DWORD Flags, FT_HANDLE * pHandle)
ftd2xx.h:223"""
# ftd2xx.h 230
FT_ListDevices = _libraries["ftd2xx.dll"].FT_ListDevices
FT_ListDevices.restype = FT_STATUS
# FT_ListDevices(pArg1, pArg2, Flags)
FT_ListDevices.argtypes = [PVOID, PVOID, DWORD]
FT_ListDevices.__doc__ = """FT_STATUS FT_ListDevices(PVOID pArg1, PVOID pArg2, DWORD Flags)
ftd2xx.h:230"""
# ftd2xx.h 235
FT_Close = _libraries["ftd2xx.dll"].FT_Close
FT_Close.restype = FT_STATUS
# FT_Close(ftHandle)
FT_Close.argtypes = [FT_HANDLE]
FT_Close.__doc__ = """FT_STATUS FT_Close(FT_HANDLE ftHandle)
ftd2xx.h:235"""
# ftd2xx.h 243
FT_Read = _libraries["ftd2xx.dll"].FT_Read
FT_Read.restype = FT_STATUS
# FT_Read(ftHandle, lpBuffer, nBufferSize, lpBytesReturned)
FT_Read.argtypes = [FT_HANDLE, LPVOID, DWORD, LPDWORD]
FT_Read.__doc__ = """FT_STATUS FT_Read(FT_HANDLE ftHandle, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesReturned)
ftd2xx.h:243"""
# ftd2xx.h 251
FT_Write = _libraries["ftd2xx.dll"].FT_Write
FT_Write.restype = FT_STATUS
# FT_Write(ftHandle, lpBuffer, nBufferSize, lpBytesWritten)
FT_Write.argtypes = [FT_HANDLE, LPVOID, DWORD, LPDWORD]
FT_Write.__doc__ = """FT_STATUS FT_Write(FT_HANDLE ftHandle, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesWritten)
ftd2xx.h:251"""
# ftd2xx.h 263
FT_IoCtl = _libraries["ftd2xx.dll"].FT_IoCtl
FT_IoCtl.restype = FT_STATUS
# FT_IoCtl(ftHandle, dwIoControlCode, lpInBuf, nInBufSize, lpOutBuf, nOutBufSize, lpBytesReturned, lpOverlapped)
FT_IoCtl.argtypes = [
    FT_HANDLE,
    DWORD,
    LPVOID,
    DWORD,
    LPVOID,
    DWORD,
    LPDWORD,
    LPOVERLAPPED,
]
FT_IoCtl.__doc__ = """FT_STATUS FT_IoCtl(FT_HANDLE ftHandle, DWORD dwIoControlCode, LPVOID lpInBuf, DWORD nInBufSize, LPVOID lpOutBuf, DWORD nOutBufSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
ftd2xx.h:263"""
# ftd2xx.h 269
FT_SetBaudRate = _libraries["ftd2xx.dll"].FT_SetBaudRate
FT_SetBaudRate.restype = FT_STATUS
# FT_SetBaudRate(ftHandle, BaudRate)
FT_SetBaudRate.argtypes = [FT_HANDLE, ULONG]
FT_SetBaudRate.__doc__ = """FT_STATUS FT_SetBaudRate(FT_HANDLE ftHandle, ULONG BaudRate)
ftd2xx.h:269"""
# ftd2xx.h 275
FT_SetDivisor = _libraries["ftd2xx.dll"].FT_SetDivisor
FT_SetDivisor.restype = FT_STATUS
# FT_SetDivisor(ftHandle, Divisor)
FT_SetDivisor.argtypes = [FT_HANDLE, USHORT]
FT_SetDivisor.__doc__ = """FT_STATUS FT_SetDivisor(FT_HANDLE ftHandle, USHORT Divisor)
ftd2xx.h:275"""
# ftd2xx.h 283
FT_SetDataCharacteristics = _libraries["ftd2xx.dll"].FT_SetDataCharacteristics
FT_SetDataCharacteristics.restype = FT_STATUS
# FT_SetDataCharacteristics(ftHandle, WordLength, StopBits, Parity)
FT_SetDataCharacteristics.argtypes = [FT_HANDLE, UCHAR, UCHAR, UCHAR]
FT_SetDataCharacteristics.__doc__ = """FT_STATUS FT_SetDataCharacteristics(FT_HANDLE ftHandle, UCHAR WordLength, UCHAR StopBits, UCHAR Parity)
ftd2xx.h:283"""
# ftd2xx.h 291
FT_SetFlowControl = _libraries["ftd2xx.dll"].FT_SetFlowControl
FT_SetFlowControl.restype = FT_STATUS
# FT_SetFlowControl(ftHandle, FlowControl, XonChar, XoffChar)
FT_SetFlowControl.argtypes = [FT_HANDLE, USHORT, UCHAR, UCHAR]
FT_SetFlowControl.__doc__ = """FT_STATUS FT_SetFlowControl(FT_HANDLE ftHandle, USHORT FlowControl, UCHAR XonChar, UCHAR XoffChar)
ftd2xx.h:291"""
# ftd2xx.h 296
FT_ResetDevice = _libraries["ftd2xx.dll"].FT_ResetDevice
FT_ResetDevice.restype = FT_STATUS
# FT_ResetDevice(ftHandle)
FT_ResetDevice.argtypes = [FT_HANDLE]
FT_ResetDevice.__doc__ = """FT_STATUS FT_ResetDevice(FT_HANDLE ftHandle)
ftd2xx.h:296"""
# ftd2xx.h 301
FT_SetDtr = _libraries["ftd2xx.dll"].FT_SetDtr
FT_SetDtr.restype = FT_STATUS
# FT_SetDtr(ftHandle)
FT_SetDtr.argtypes = [FT_HANDLE]
FT_SetDtr.__doc__ = """FT_STATUS FT_SetDtr(FT_HANDLE ftHandle)
ftd2xx.h:301"""
# ftd2xx.h 306
FT_ClrDtr = _libraries["ftd2xx.dll"].FT_ClrDtr
FT_ClrDtr.restype = FT_STATUS
# FT_ClrDtr(ftHandle)
FT_ClrDtr.argtypes = [FT_HANDLE]
FT_ClrDtr.__doc__ = """FT_STATUS FT_ClrDtr(FT_HANDLE ftHandle)
ftd2xx.h:306"""
# ftd2xx.h 311
FT_SetRts = _libraries["ftd2xx.dll"].FT_SetRts
FT_SetRts.restype = FT_STATUS
# FT_SetRts(ftHandle)
FT_SetRts.argtypes = [FT_HANDLE]
FT_SetRts.__doc__ = """FT_STATUS FT_SetRts(FT_HANDLE ftHandle)
ftd2xx.h:311"""
# ftd2xx.h 316
FT_ClrRts = _libraries["ftd2xx.dll"].FT_ClrRts
FT_ClrRts.restype = FT_STATUS
# FT_ClrRts(ftHandle)
FT_ClrRts.argtypes = [FT_HANDLE]
FT_ClrRts.__doc__ = """FT_STATUS FT_ClrRts(FT_HANDLE ftHandle)
ftd2xx.h:316"""
# ftd2xx.h 322
FT_GetModemStatus = _libraries["ftd2xx.dll"].FT_GetModemStatus
FT_GetModemStatus.restype = FT_STATUS
# FT_GetModemStatus(ftHandle, pModemStatus)
FT_GetModemStatus.argtypes = [FT_HANDLE, POINTER(ULONG)]
FT_GetModemStatus.__doc__ = """FT_STATUS FT_GetModemStatus(FT_HANDLE ftHandle, ULONG * pModemStatus)
ftd2xx.h:322"""
# ftd2xx.h 331
FT_SetChars = _libraries["ftd2xx.dll"].FT_SetChars
FT_SetChars.restype = FT_STATUS
# FT_SetChars(ftHandle, EventChar, EventCharEnabled, ErrorChar, ErrorCharEnabled)
FT_SetChars.argtypes = [FT_HANDLE, UCHAR, UCHAR, UCHAR, UCHAR]
FT_SetChars.__doc__ = """FT_STATUS FT_SetChars(FT_HANDLE ftHandle, UCHAR EventChar, UCHAR EventCharEnabled, UCHAR ErrorChar, UCHAR ErrorCharEnabled)
ftd2xx.h:331"""
# ftd2xx.h 337
FT_Purge = _libraries["ftd2xx.dll"].FT_Purge
FT_Purge.restype = FT_STATUS
# FT_Purge(ftHandle, Mask)
FT_Purge.argtypes = [FT_HANDLE, ULONG]
FT_Purge.__doc__ = """FT_STATUS FT_Purge(FT_HANDLE ftHandle, ULONG Mask)
ftd2xx.h:337"""
# ftd2xx.h 344
FT_SetTimeouts = _libraries["ftd2xx.dll"].FT_SetTimeouts
FT_SetTimeouts.restype = FT_STATUS
# FT_SetTimeouts(ftHandle, ReadTimeout, WriteTimeout)
FT_SetTimeouts.argtypes = [FT_HANDLE, ULONG, ULONG]
FT_SetTimeouts.__doc__ = """FT_STATUS FT_SetTimeouts(FT_HANDLE ftHandle, ULONG ReadTimeout, ULONG WriteTimeout)
ftd2xx.h:344"""
# ftd2xx.h 350
FT_GetQueueStatus = _libraries["ftd2xx.dll"].FT_GetQueueStatus
FT_GetQueueStatus.restype = FT_STATUS
# FT_GetQueueStatus(ftHandle, dwRxBytes)
FT_GetQueueStatus.argtypes = [FT_HANDLE, POINTER(DWORD)]
FT_GetQueueStatus.__doc__ = """FT_STATUS FT_GetQueueStatus(FT_HANDLE ftHandle, DWORD * dwRxBytes)
ftd2xx.h:350"""
# ftd2xx.h 357
FT_SetEventNotification = _libraries["ftd2xx.dll"].FT_SetEventNotification
FT_SetEventNotification.restype = FT_STATUS
# FT_SetEventNotification(ftHandle, Mask, Param)
FT_SetEventNotification.argtypes = [FT_HANDLE, DWORD, PVOID]
FT_SetEventNotification.__doc__ = """FT_STATUS FT_SetEventNotification(FT_HANDLE ftHandle, DWORD Mask, PVOID Param)
ftd2xx.h:357"""
# ftd2xx.h 365
FT_GetStatus = _libraries["ftd2xx.dll"].FT_GetStatus
FT_GetStatus.restype = FT_STATUS
# FT_GetStatus(ftHandle, dwRxBytes, dwTxBytes, dwEventDWord)
FT_GetStatus.argtypes = [FT_HANDLE, POINTER(DWORD), POINTER(DWORD), POINTER(DWORD)]
FT_GetStatus.__doc__ = """FT_STATUS FT_GetStatus(FT_HANDLE ftHandle, DWORD * dwRxBytes, DWORD * dwTxBytes, DWORD * dwEventDWord)
ftd2xx.h:365"""
# ftd2xx.h 370
FT_SetBreakOn = _libraries["ftd2xx.dll"].FT_SetBreakOn
FT_SetBreakOn.restype = FT_STATUS
# FT_SetBreakOn(ftHandle)
FT_SetBreakOn.argtypes = [FT_HANDLE]
FT_SetBreakOn.__doc__ = """FT_STATUS FT_SetBreakOn(FT_HANDLE ftHandle)
ftd2xx.h:370"""
# ftd2xx.h 375
FT_SetBreakOff = _libraries["ftd2xx.dll"].FT_SetBreakOff
FT_SetBreakOff.restype = FT_STATUS
# FT_SetBreakOff(ftHandle)
FT_SetBreakOff.argtypes = [FT_HANDLE]
FT_SetBreakOff.__doc__ = """FT_STATUS FT_SetBreakOff(FT_HANDLE ftHandle)
ftd2xx.h:375"""
# ftd2xx.h 381
FT_SetWaitMask = _libraries["ftd2xx.dll"].FT_SetWaitMask
FT_SetWaitMask.restype = FT_STATUS
# FT_SetWaitMask(ftHandle, Mask)
FT_SetWaitMask.argtypes = [FT_HANDLE, DWORD]
FT_SetWaitMask.__doc__ = """FT_STATUS FT_SetWaitMask(FT_HANDLE ftHandle, DWORD Mask)
ftd2xx.h:381"""
# ftd2xx.h 387
FT_WaitOnMask = _libraries["ftd2xx.dll"].FT_WaitOnMask
FT_WaitOnMask.restype = FT_STATUS
# FT_WaitOnMask(ftHandle, Mask)
FT_WaitOnMask.argtypes = [FT_HANDLE, POINTER(DWORD)]
FT_WaitOnMask.__doc__ = """FT_STATUS FT_WaitOnMask(FT_HANDLE ftHandle, DWORD * Mask)
ftd2xx.h:387"""
# ftd2xx.h 393
FT_GetEventStatus = _libraries["ftd2xx.dll"].FT_GetEventStatus
FT_GetEventStatus.restype = FT_STATUS
# FT_GetEventStatus(ftHandle, dwEventDWord)
FT_GetEventStatus.argtypes = [FT_HANDLE, POINTER(DWORD)]
FT_GetEventStatus.__doc__ = """FT_STATUS FT_GetEventStatus(FT_HANDLE ftHandle, DWORD * dwEventDWord)
ftd2xx.h:393"""
# ftd2xx.h 400
FT_ReadEE = _libraries["ftd2xx.dll"].FT_ReadEE
FT_ReadEE.restype = FT_STATUS
# FT_ReadEE(ftHandle, dwWordOffset, lpwValue)
FT_ReadEE.argtypes = [FT_HANDLE, DWORD, LPWORD]
FT_ReadEE.__doc__ = """FT_STATUS FT_ReadEE(FT_HANDLE ftHandle, DWORD dwWordOffset, LPWORD lpwValue)
ftd2xx.h:400"""
# ftd2xx.h 407
FT_WriteEE = _libraries["ftd2xx.dll"].FT_WriteEE
FT_WriteEE.restype = FT_STATUS
# FT_WriteEE(ftHandle, dwWordOffset, wValue)
FT_WriteEE.argtypes = [FT_HANDLE, DWORD, WORD]
FT_WriteEE.__doc__ = """FT_STATUS FT_WriteEE(FT_HANDLE ftHandle, DWORD dwWordOffset, WORD wValue)
ftd2xx.h:407"""
# ftd2xx.h 412
FT_EraseEE = _libraries["ftd2xx.dll"].FT_EraseEE
FT_EraseEE.restype = FT_STATUS
# FT_EraseEE(ftHandle)
FT_EraseEE.argtypes = [FT_HANDLE]
FT_EraseEE.__doc__ = """FT_STATUS FT_EraseEE(FT_HANDLE ftHandle)
ftd2xx.h:412"""
# ftd2xx.h 417


# structure to hold program data for FT_EE_Program, FT_EE_ProgramEx, FT_EE_Read 
# and FT_EE_ReadEx functions
class ft_program_data(Structure):
    _fields_ = [
        # ftd2xx.h 417

        ("Signature1", DWORD),  # Header - must be 0x00000000 
        ("Signature2", DWORD),  # Header - must be 0xffffffff
        ("Version", DWORD),     # Header - FT_PROGRAM_DATA version
		# 0 = original
		# 1 = FT2232 extensions
		# 2 = FT232R extensions
		# 3 = FT2232H extensions
		# 4 = FT4232H extensions
		# 5 = FT232H extensions

        ("VendorId", WORD),          # 0x0403
        ("ProductId", WORD),         # 0x6001
        ("Manufacturer", STRING),    # "FTDI"
        ("ManufacturerId", STRING),  # "FT"
        ("Description", STRING),     # "USB HS Serial Converter"
        ("SerialNumber", STRING),    # "FT000001" if fixed, or NULL
        ("MaxPower", WORD),          # 0 < MaxPower <= 500
        ("PnP", WORD),               # 0 = disabled, 1 = enabled
        ("SelfPowered", WORD),       # 0 = bus powered, 1 = self powe
        ("RemoteWakeup", WORD),      # 0 = not capable, 1 = capable

        # Rev4 (FT232B) extensions
        ("Rev4", UCHAR),              # non-zero if Rev4 chip, zero otherwise
        ("IsoIn", UCHAR),             # non-zero if in endpoint is isochronous
        ("IsoOut", UCHAR),            # non-zero if out endpoint is isochronous
        ("PullDownEnable", UCHAR),    # non-zero if pull down enabled
        ("SerNumEnable", UCHAR),      # non-zero if serial number to be used
        ("USBVersionEnable", UCHAR),  # non-zero if chip uses USBVersion
        ("USBVersion", WORD),         # BCD (0x0200 => USB2)

        #Rev 5 (FT2232) extensions
        ("Rev5", UCHAR),               # non-zero if Rev5 chip, zero otherwise
        ("IsoInA", UCHAR),             # non-zero if in endpoint is isochronous
        ("IsoInB", UCHAR),             # non-zero if in endpoint is isochronous
        ("IsoOutA", UCHAR),            # non-zero if out endpoint is isochronous
        ("IsoOutB", UCHAR),            # non-zero if out endpoint is isochronous
        ("PullDownEnable5", UCHAR),    # non-zero if pull down enabled
        ("SerNumEnable5", UCHAR),      # non-zero if serial number to be used
        ("USBVersionEnable5", UCHAR),  # non-zero if chip uses USBVersion
        ("USBVersion5", WORD),         # BCD (0x0200 => USB2)
        ("AIsHighCurrent", UCHAR),     # non-zero if interface is high current
        ("BIsHighCurrent", UCHAR),     # non-zero if interface is high current
        ("IFAIsFifo", UCHAR),          # non-zero if interface is 245 FIFO
        ("IFAIsFifoTar", UCHAR),       # non-zero if interface is 245 FIFO CPU target
        ("IFAIsFastSer", UCHAR),       # non-zero if interface is Fast serial
        ("AIsVCP", UCHAR),             # non-zero if interface is to use VCP drivers
        ("IFBIsFifo", UCHAR),          # non-zero if interface is 245 FIFO
        ("IFBIsFifoTar", UCHAR),       # non-zero if interface is 245 FIFO CPU target
        ("IFBIsFastSer", UCHAR),       # non-zero if interface is Fast serial
        ("BIsVCP", UCHAR),             # non-zero if interface is to use VCP drivers


        # Rev 6 (FT232R) extensions
        ("UseExtOsc", UCHAR),        # Use External Oscillator
        ("HighDriveIOs", UCHAR),     # High Drive I/Os
        ("EndpointSize", UCHAR),     # Endpoint size
        ("PullDownEnableR", UCHAR),  # non-zero if pull down enabled
        ("SerNumEnableR", UCHAR),    # non-zero if serial number to be used
        ("InvertTXD", UCHAR),        # non-zero if invert TXD
        ("InvertRXD", UCHAR),        # non-zero if invert RXD
        ("InvertRTS", UCHAR),        # non-zero if invert RTS
        ("InvertCTS", UCHAR),        # non-zero if invert CTS
        ("InvertDTR", UCHAR),        # non-zero if invert DTR
        ("InvertDSR", UCHAR),        # non-zero if invert DSR
        ("InvertDCD", UCHAR),        # non-zero if invert DCD
        ("InvertRI", UCHAR),         # non-zero if invert RI
        ("Cbus0", UCHAR),            # Cbus Mux control
        ("Cbus1", UCHAR),            # Cbus Mux control
        ("Cbus2", UCHAR),            # Cbus Mux control
        ("Cbus3", UCHAR),            # Cbus Mux control
        ("Cbus4", UCHAR),            # Cbus Mux control
        ("RIsVCP", UCHAR),           # non-zero if using D2XX driver

        # Rev 7 (FT2232H) Extensions
        ("PullDownEnable7", UCHAR),  # non-zero if pull down enabled
        ("SerNumEnable7", UCHAR),    # non-zero if serial number to be used
        ("ALSlowSlew", UCHAR),       # non-zero if AL pins have slow slew
        ("ALSchmittInput", UCHAR),   # non-zero if AL pins are Schmitt input
        ("ALDriveCurrent", UCHAR),   # valid values are 4mA, 8mA, 12mA, 16mA
        ("AHSlowSlew", UCHAR),       # non-zero if AH pins have slow slew
        ("AHSchmittInput", UCHAR),   # non-zero if AH pins are Schmitt input
        ("AHDriveCurrent", UCHAR),   # valid values are 4mA, 8mA, 12mA, 16mA
        ("BLSlowSlew", UCHAR),       # non-zero if BL pins have slow slew
        ("BLSchmittInput", UCHAR),   # non-zero if BL pins are Schmitt input
        ("BLDriveCurrent", UCHAR),   # valid values are 4mA, 8mA, 12mA, 16mA
        ("BHSlowSlew", UCHAR),       # non-zero if BH pins have slow slew
        ("BHSchmittInput", UCHAR),   # non-zero if BH pins are Schmitt input
        ("BHDriveCurrent", UCHAR),   # valid values are 4mA, 8mA, 12mA, 16mA
        ("IFAIsFifo7", UCHAR),       # non-zero if interface is 245 FIFO
        ("IFAIsFifoTar7", UCHAR),    # non-zero if interface is 245 FIFO CPU target
        ("IFAIsFastSer7", UCHAR),    # non-zero if interface is Fast serial
        ("AIsVCP7", UCHAR),          # non-zero if interface is to use VCP drivers
        ("IFBIsFifo7", UCHAR),       # non-zero if interface is 245 FIFO
        ("IFBIsFifoTar7", UCHAR),    # non-zero if interface is 245 FIFO CPU target
        ("IFBIsFastSer7", UCHAR),    # non-zero if interface is Fast serial
        ("BIsVCP7", UCHAR),          # non-zero if interface is to use VCP drivers
        ("PowerSaveEnable", UCHAR),  # non-zero if using BCBUS7 to save power for self-powered designs


        # Rev 8 (FT4232H) Extensions
        ("PullDownEnable8", UCHAR),  # non-zero if pull down enabled
        ("SerNumEnable8", UCHAR),    # non-zero if serial number to be used
        ("ASlowSlew", UCHAR),        # non-zero if A pins have slow slew
        ("ASchmittInput", UCHAR),    # non-zero if A pins are Schmitt input
        ("ADriveCurrent", UCHAR),    # valid values are 4mA, 8mA, 12mA, 16mA
        ("BSlowSlew", UCHAR),        # non-zero if B pins have slow slew
        ("BSchmittInput", UCHAR),    # non-zero if B pins are Schmitt input
        ("BDriveCurrent", UCHAR),    # valid values are 4mA, 8mA, 12mA, 16mA
        ("CSlowSlew", UCHAR),        # non-zero if C pins have slow slew
        ("CSchmittInput", UCHAR),    # non-zero if C pins are Schmitt input
        ("CDriveCurrent", UCHAR),    # valid values are 4mA, 8mA, 12mA, 16mA
        ("DSlowSlew", UCHAR),        # non-zero if D pins have slow slew
        ("DSchmittInput", UCHAR),    # non-zero if D pins are Schmitt input
        ("DDriveCurrent", UCHAR),    # valid values are 4mA, 8mA, 12mA, 16mA
        ("ARIIsTXDEN", UCHAR),       # non-zero if port A uses RI as RS485 TXDEN
        ("BRIIsTXDEN", UCHAR),       # non-zero if port B uses RI as RS485 TXDEN
        ("CRIIsTXDEN", UCHAR),       # non-zero if port C uses RI as RS485 TXDEN
        ("DRIIsTXDEN", UCHAR),       # non-zero if port D uses RI as RS485 TXDEN
        ("AIsVCP8", UCHAR),          # non-zero if interface is to use VCP drivers
        ("BIsVCP8", UCHAR),          # non-zero if interface is to use VCP drivers
        ("CIsVCP8", UCHAR),          # non-zero if interface is to use VCP drivers
        ("DIsVCP8", UCHAR),          # non-zero if interface is to use VCP drivers

        # Rev 9 (FT232H) Extensions
        ("PullDownEnableH", UCHAR),     # non-zero if pull down enabled
        ("SerNumEnableH", UCHAR),       # non-zero if serial number to be used
        ("ACSlowSlewH", UCHAR),         # non-zero if AC pins have slow slew
        ("ACSchmittInputH", UCHAR),     # non-zero if AC pins are Schmitt input
        ("ACDriveCurrentH", UCHAR),     # valid values are 4mA, 8mA, 12mA, 16mA
        ("ADSlowSlewH", UCHAR),         # non-zero if AD pins have slow slew
        ("ADSchmittInputH", UCHAR),     # non-zero if AD pins are Schmitt input
        ("ADDriveCurrentH", UCHAR),     # valid values are 4mA, 8mA, 12mA, 16mA
        ("Cbus0H", UCHAR),              # Cbus Mux control
        ("Cbus1H", UCHAR),              # Cbus Mux control
        ("Cbus2H", UCHAR),              # Cbus Mux control
        ("Cbus3H", UCHAR),              # Cbus Mux control
        ("Cbus4H", UCHAR),              # Cbus Mux control
        ("Cbus5H", UCHAR),              # Cbus Mux control
        ("Cbus6H", UCHAR),              # Cbus Mux control
        ("Cbus7H", UCHAR),              # Cbus Mux control
        ("Cbus8H", UCHAR),              # Cbus Mux control
        ("Cbus9H", UCHAR),              # Cbus Mux control
        ("IsFifoH", UCHAR),             # non-zero if interface is 245 FIFO
        ("IsFifoTarH", UCHAR),          # non-zero if interface is 245 FIFO CPU target
        ("IsFastSerH", UCHAR),          # non-zero if interface is Fast serial
        ("IsFT1248H", UCHAR),           # non-zero if interface is FT1248
        ("FT1248CpolH", UCHAR),         # FT1248 clock polarity - clock idle high (1) or clock idle low (0)
        ("FT1248LsbH", UCHAR),          # FT1248 data is LSB (1) or MSB (0)
        ("FT1248FlowControlH", UCHAR),  # FT1248 flow control enable
        ("IsVCPH", UCHAR),              # non-zero if interface is to use VCP drivers
        ("PowerSaveEnableH", UCHAR),    # non-zero if using ACBUS7 to save power for self-powered designs
    ]


PFT_PROGRAM_DATA = POINTER(ft_program_data)
FT_PROGRAM_DATA = ft_program_data
# ftd2xx.h 501
FT_EE_Program = _libraries["ftd2xx.dll"].FT_EE_Program
FT_EE_Program.restype = FT_STATUS
# FT_EE_Program(ftHandle, pData)
FT_EE_Program.argtypes = [FT_HANDLE, PFT_PROGRAM_DATA]
FT_EE_Program.__doc__ = """FT_STATUS FT_EE_Program(FT_HANDLE ftHandle, PFT_PROGRAM_DATA pData)
ftd2xx.h:501"""
# ftd2xx.h 511
FT_EE_ProgramEx = _libraries["ftd2xx.dll"].FT_EE_ProgramEx
FT_EE_ProgramEx.restype = FT_STATUS
# FT_EE_ProgramEx(ftHandle, pData, Manufacturer, ManufacturerId, Description, SerialNumber)
FT_EE_ProgramEx.argtypes = [FT_HANDLE, PFT_PROGRAM_DATA, STRING, STRING, STRING, STRING]
FT_EE_ProgramEx.__doc__ = """FT_STATUS FT_EE_ProgramEx(FT_HANDLE ftHandle, PFT_PROGRAM_DATA pData, char * Manufacturer, char * ManufacturerId, char * Description, char * SerialNumber)
ftd2xx.h:511"""
# ftd2xx.h 517
FT_EE_Read = _libraries["ftd2xx.dll"].FT_EE_Read
FT_EE_Read.restype = FT_STATUS
# FT_EE_Read(ftHandle, pData)
FT_EE_Read.argtypes = [FT_HANDLE, PFT_PROGRAM_DATA]
FT_EE_Read.__doc__ = """FT_STATUS FT_EE_Read(FT_HANDLE ftHandle, PFT_PROGRAM_DATA pData)
ftd2xx.h:517"""
# ftd2xx.h 527
FT_EE_ReadEx = _libraries["ftd2xx.dll"].FT_EE_ReadEx
FT_EE_ReadEx.restype = FT_STATUS
# FT_EE_ReadEx(ftHandle, pData, Manufacturer, ManufacturerId, Description, SerialNumber)
FT_EE_ReadEx.argtypes = [FT_HANDLE, PFT_PROGRAM_DATA, STRING, STRING, STRING, STRING]
FT_EE_ReadEx.__doc__ = """FT_STATUS FT_EE_ReadEx(FT_HANDLE ftHandle, PFT_PROGRAM_DATA pData, char * Manufacturer, char * ManufacturerId, char * Description, char * SerialNumber)
ftd2xx.h:527"""
# ftd2xx.h 533
FT_EE_UASize = _libraries["ftd2xx.dll"].FT_EE_UASize
FT_EE_UASize.restype = FT_STATUS
# FT_EE_UASize(ftHandle, lpdwSize)
FT_EE_UASize.argtypes = [FT_HANDLE, LPDWORD]
FT_EE_UASize.__doc__ = """FT_STATUS FT_EE_UASize(FT_HANDLE ftHandle, LPDWORD lpdwSize)
ftd2xx.h:533"""
# ftd2xx.h 540
FT_EE_UAWrite = _libraries["ftd2xx.dll"].FT_EE_UAWrite
FT_EE_UAWrite.restype = FT_STATUS
# FT_EE_UAWrite(ftHandle, pucData, dwDataLen)
FT_EE_UAWrite.argtypes = [FT_HANDLE, PUCHAR, DWORD]
FT_EE_UAWrite.__doc__ = """FT_STATUS FT_EE_UAWrite(FT_HANDLE ftHandle, PUCHAR pucData, DWORD dwDataLen)
ftd2xx.h:540"""
# ftd2xx.h 548
FT_EE_UARead = _libraries["ftd2xx.dll"].FT_EE_UARead
FT_EE_UARead.restype = FT_STATUS
# FT_EE_UARead(ftHandle, pucData, dwDataLen, lpdwBytesRead)
FT_EE_UARead.argtypes = [FT_HANDLE, PUCHAR, DWORD, LPDWORD]
FT_EE_UARead.__doc__ = """FT_STATUS FT_EE_UARead(FT_HANDLE ftHandle, PUCHAR pucData, DWORD dwDataLen, LPDWORD lpdwBytesRead)
ftd2xx.h:548"""

# Base struct to hold programming data for FT_EEPROM_Program, FT_EEPROM_Read
class ft_eeprom_header(Structure):
    _fields_ = [
        ("deviceType", FT_DEVICE),  # FTxxxx device type to be programmed
        # Device descriptor options
        ("VendorId", WORD),       # 0x0403
        ("ProductId", WORD),      # 0x6001
        ("SerNumEnable", UCHAR),  # non-zero if serial number to be used
        # Config descriptor options
        ("MaxPower", WORD),       # 0 < MaxPower <= 500
        ("SelfPowered", UCHAR),   # 0 = bus powered, 1 = self powered
        ("RemoteWakeup", UCHAR),  # 0 = not capable, 1 = capable
        # Hardware options
        ("PullDownEnable", UCHAR),  # non-zero if pull down in suspend enabled
    ]
PFT_EEPROM_HEADER = POINTER(ft_eeprom_header)
FT_EEPROM_HEADER = ft_eeprom_header

# FT232B EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
class ft_eeprom_232b(Structure):
    _fields_ = [
        # Common header
        ("common", FT_EEPROM_HEADER),  # common elements for all device EEPROMs
    ]
PFT_EEPROM_232B = POINTER(ft_eeprom_232b)
FT_EEPROM_232B = ft_eeprom_232b

# FT2232 EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
class ft_eeprom_2232(Structure):
    _fields_ = [
        # Common header
        ("common", FT_EEPROM_HEADER),  # common elements for all device EEPROMs
        # Drive options
        ("AIsHighCurrent", UCHAR),  # non-zero if interface is high current
        ("BIsHighCurrent", UCHAR),  # non-zero if interface is high current
        # Hardware options
        ("AIsFifo", UCHAR),     # non-zero if interface is 243 FIFO
        ("AIsFifoTar", UCHAR),  # non-zero if interface is 243 FIFO CPU target
        ("AIsFastSer", UCHAR),  # non-zero if interface is 243 Fast serial
        ("BIsFifo", UCHAR),     # non-zero if interface is 243 FIFO
        ("BIsFifoTar", UCHAR),  # non-zero if interface is 243 FIFO CPU target
        ("BIsFastSer", UCHAR),  # non-zero if interface is 243 Fast serial
        # Driver option
        ("ADriverType", UCHAR),  # non-zero if interface is to use VCP drivers
        ("BDriverType", UCHAR),  # non-zero if interface is to use VCP drivers
    ]
PFT_EEPROM_2232 = POINTER(ft_eeprom_2232)
FT_EEPROM_2232 = ft_eeprom_2232

# FT232r EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
class ft_eeprom_232r(Structure):
    _fields_ = [
        # Common header
        ("common", FT_EEPROM_HEADER),  # common elements for all device EEPROMs
        # Drive options
        ("IsHighCurrent", UCHAR),  # non-zero if interface is high current
        # Hardware options
        ("UseExtOsc", UCHAR),  # Use External Oscillator
        ("InvertTXD", UCHAR),  # non-zero if invert TXD
        ("InvertRXD", UCHAR),  # non-zero if invert RXD
        ("InvertRTS", UCHAR),  # non-zero if invert RTS
        ("InvertCTS", UCHAR),  # non-zero if invert CTS
        ("InvertDTR", UCHAR),  # non-zero if invert DTR
        ("InvertDSR", UCHAR),  # non-zero if invert DSR
        ("InvertDCD", UCHAR),  # non-zero if invert DCD
        ("InvertRI", UCHAR),   # non-zero if invert RI
        ("Cbus0", UCHAR),      # Cbus Mux control
        ("Cbus1", UCHAR),      # Cbus Mux control
        ("Cbus2", UCHAR),      # Cbus Mux control
        ("Cbus3", UCHAR),      # Cbus Mux control
        ("Cbus4", UCHAR),      # Cbus Mux control
        # Driver option
        ("DriverType", UCHAR),  # non-zero if using D2XX driver
    ]
PFT_EEPROM_232R = POINTER(ft_eeprom_232r)
FT_EEPROM_232R = ft_eeprom_232r

# FT2232H EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
class ft_eeprom_2232h(Structure):
    _fields_ = [
        # Common header
        ("common", FT_EEPROM_HEADER),  # common elements for all device EEPROMs
        # Drive options
        ("ALSlowSlew", UCHAR),      # non-zero if AL pins have slow slew
        ("ALSchmittInput", UCHAR),  # non-zero if AL pins are Schmitt input
        ("ALDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        ("AHSlowSlew", UCHAR),      # non-zero if AH pins have slow slew
        ("AHSchmittInput", UCHAR),  # non-zero if AH pins are Schmitt input
        ("AHDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        ("BLSlowSlew", UCHAR),      # non-zero if BL pins have slow slew
        ("BLSchmittInput", UCHAR),  # non-zero if BL pins are Schmitt input
        ("BLDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        ("BHSlowSlew", UCHAR),      # non-zero if BH pins have slow slew
        ("BHSchmittInput", UCHAR),  # non-zero if BH pins are Schmitt input
        ("BHDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        # Hardware options
        ("AIsFifo", UCHAR),          # non-zero if interface is 243 FIFO
        ("AIsFifoTar", UCHAR),       # non-zero if interface is 243 FIFO CPU target
        ("AIsFastSer", UCHAR),       # non-zero if interface is 243 Fast serial
        ("BIsFifo", UCHAR),          # non-zero if interface is 243 FIFO
        ("BIsFifoTar", UCHAR),       # non-zero if interface is 243 FIFO CPU target
        ("BIsFastSer", UCHAR),       # non-zero if interface is 243 Fast serial
        ("PowerSaveEnable", UCHAR),  # non-zero if using BCBUS7 to save power for self-powered designs
        # Driver option
        ("ADriverType", UCHAR),  # non-zero if interface is to use VCP drivers
        ("BDriverType", UCHAR),  # non-zero if interface is to use VCP drivers
    ]
PFT_EEPROM_2232H = POINTER(ft_eeprom_2232h)
FT_EEPROM_2232H = ft_eeprom_2232h

# FT4232H EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
class ft_eeprom_4232h(Structure):
    _fields_ = [
        # Common header
        ("common", FT_EEPROM_HEADER),  # common elements for all device EEPROMs
        # Drive options
        ("ASlowSlew", UCHAR),      # non-zero if A pins have slow slew
        ("ASchmittInput", UCHAR),  # non-zero if A pins are Schmitt input
        ("ADriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        ("BSlowSlew", UCHAR),      # non-zero if B pins have slow slew
        ("BSchmittInput", UCHAR),  # non-zero if B pins are Schmitt input
        ("BDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        ("CSlowSlew", UCHAR),      # non-zero if C pins have slow slew
        ("CSchmittInput", UCHAR),  # non-zero if C pins are Schmitt input
        ("CDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        ("DSlowSlew", UCHAR),      # non-zero if D pins have slow slew
        ("DSchmittInput", UCHAR),  # non-zero if D pins are Schmitt input
        ("DDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        # Hardware options
        ("ARIIsTXDEN", UCHAR),          # non-zero if port A uses RI as RS485 TXDEN
        ("BRIIsTXDEN", UCHAR),          # non-zero if port B uses RI as RS485 TXDEN
        ("CRIIsTXDEN", UCHAR),          # non-zero if port C uses RI as RS485 TXDEN
        ("DRIIsTXDEN", UCHAR),          # non-zero if port D uses RI as RS485 TXDEN
        # Driver option
        ("ADriverType", UCHAR),  # non-zero if interface is to use VCP drivers
        ("BDriverType", UCHAR),  # non-zero if interface is to use VCP drivers
        ("CDriverType", UCHAR),  # non-zero if interface is to use VCP drivers
        ("DDriverType", UCHAR),  # non-zero if interface is to use VCP drivers
    ]
PFT_EEPROM_4232H = POINTER(ft_eeprom_4232h)
FT_EEPROM_4232H = ft_eeprom_4232h

# FT232H EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
class ft_eeprom_232h(Structure):
    _fields_ = [
        # Common header
        ("common", FT_EEPROM_HEADER),  # common elements for all device EEPROMs
        # Drive options
        ("ACSlowSlew", UCHAR),      # non-zero if AC pins have slow slew
        ("ACSchmittInput", UCHAR),  # non-zero if AC pins are Schmitt input
        ("ACDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        ("ADSlowSlew", UCHAR),      # non-zero if AD pins have slow slew
        ("ADSchmittInput", UCHAR),  # non-zero if AD pins are Schmitt input
        ("ADDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        # CBUS options
        ("Cbus0", UCHAR),  # Cbus Mux control
        ("Cbus1", UCHAR),  # Cbus Mux control
        ("Cbus2", UCHAR),  # Cbus Mux control
        ("Cbus3", UCHAR),  # Cbus Mux control
        ("Cbus4", UCHAR),  # Cbus Mux control
        ("Cbus5", UCHAR),  # Cbus Mux control
        ("Cbus6", UCHAR),  # Cbus Mux control
        ("Cbus7", UCHAR),  # Cbus Mux control
        ("Cbus8", UCHAR),  # Cbus Mux control
        ("Cbus9", UCHAR),  # Cbus Mux control
        # FT1248 options
        ("FT1248Cpol", UCHAR),         # FT1248 clock polarity - clock idle high (1) or clock idle low (0)
        ("FT1248Lsb", UCHAR),          # FT1248 data is LSB(1) or MSB (0)
        ("FT1248FlowControl", UCHAR),  # FT1248 flow control enable
        # Hardware options
        ("IsFifo", UCHAR),           # non-zero if interface is 245 FIFO
        ("IsFifoTar", UCHAR),        # non-zero if interface is 245 FIFO CPU target
        ("IsFastSer", UCHAR),        # non-zero if interface is Fast serial
        ("IsFT1248", UCHAR),         # non-zero if interface is FT1248
        ("PowerSaveEnable", UCHAR),  #
        # Driver option
        ("DriverType", UCHAR),  # non-zero if interface is to use VCP drivers
    ]
PFT_EEPROM_232H = POINTER(ft_eeprom_232h)
FT_EEPROM_232H = ft_eeprom_232h

# FT X SERIES EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
class ft_eeprom_x_series(Structure):
    _fields_ = [
        # Common header
        ("common", FT_EEPROM_HEADER),  # common elements for all device EEPROMs
        # Drive options
        ("ACSlowSlew", UCHAR),      # non-zero if AC pins have slow slew
        ("ACSchmittInput", UCHAR),  # non-zero if AC pins are Schmitt input
        ("ACDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        ("ADSlowSlew", UCHAR),      # non-zero if AD pins have slow slew
        ("ADSchmittInput", UCHAR),  # non-zero if AD pins are Schmitt input
        ("ADDriveCurrent", UCHAR),  # valid values are 4mA, 8mA, 12mA, 16mA
        # CBUS options
        ("Cbus0", UCHAR),  # Cbus Mux control
        ("Cbus1", UCHAR),  # Cbus Mux control
        ("Cbus2", UCHAR),  # Cbus Mux control
        ("Cbus3", UCHAR),  # Cbus Mux control
        ("Cbus4", UCHAR),  # Cbus Mux control
        ("Cbus5", UCHAR),  # Cbus Mux control
        ("Cbus6", UCHAR),  # Cbus Mux control
        # UART signal options
        ("InvertTXD", UCHAR),  # non-zero if invert TXD
        ("InvertRXD", UCHAR),  # non-zero if invert RXD
        ("InvertRTS", UCHAR),  # non-zero if invert RTS
        ("InvertCTS", UCHAR),  # non-zero if invert CTS
        ("InvertDTR", UCHAR),  # non-zero if invert DTR
        ("InvertDSR", UCHAR),  # non-zero if invert DSR
        ("InvertDCD", UCHAR),  # non-zero if invert DCD
        ("InvertRI", UCHAR),   # non-zero if invert RI
        # Battery Charge Detect options
        ("BCDEnable", UCHAR),          # Enable Battery Charger Detection
        ("BCDForceCbusPWREN", UCHAR),  # asserts the power enable signal on CBUS when charging port detected
        ("BCDDisableSleep", UCHAR),    # forces the device to never go into sleep mode
        # I2C options
        ("I2CSlaveAddress", WORD),     # I2C slave device address
        ("I2CDeviceId", DWORD),        # I2C device ID
        ("I2CDisableSchmitt", UCHAR),  # Disable I2C Schmitt trigger
        # FT1248 options
        ("FT1248Cpol", UCHAR),         # FT1248 clock polarity - clock idle high (1) or clock idle low (0)
        ("FT1248Lsb", UCHAR),          # FT1248 data is LSB(1) or MSB (0)
        ("FT1248FlowControl", UCHAR),  # FT1248 flow control enable
        # Hardware options
        ("RS485EchoSuppress", UCHAR),  # non-zero if interface is 245 FIFO
        ("PowerSaveEnable", UCHAR),    #
        # Driver option
        ("DriverType", UCHAR),  # non-zero if interface is to use VCP drivers
    ]
PFT_EEPROM_X_SERIES = POINTER(ft_eeprom_x_series)
FT_EEPROM_X_SERIES = ft_eeprom_x_series

# FT4222H EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
class ft_eeprom_4222h(Structure):
    _fields_ = [
        # Common header
        ("common", FT_EEPROM_HEADER),  # common elements for all device EEPROMs
        ("Revision", CHAR),            # 'A', 'B', 'C', or 'D'.
        ("I2C_Slave_Address", UCHAR),
        # Suspend
        ("SPISuspend", UCHAR),        # 0 for "Disable SPI, tristate pins", 2 for "Keep SPI pin status", 3 for "Enable SPI pin control"
        ("SuspendOutPol", UCHAR),     # 0 for negative, 1 for positive (not implemented on Rev A)
        ("EnableSuspendOut", UCHAR),  # non-zero to enable (not implemented on Rev A)
        # QSPI
        ("Clock_SlowSlew", UCHAR),        # non-zero if clock pin has slow slew
        ("Clock_Drive", UCHAR),           # valid values are 4mA, 8mA, 12mA, 16mA
        ("IO0_SlowSlew", UCHAR),          # non-zero if IO0 pin has slow slew
        ("IO1_SlowSlew", UCHAR),          # non-zero if IO1 pin has slow slew
        ("IO2_SlowSlew", UCHAR),          # non-zero if IO2 pin has slow slew
        ("IO3_SlowSlew", UCHAR),          # non-zero if IO3 pin has slow slew
        ("IO_Drive", UCHAR),              # valid values are 4mA, 8mA, 12mA, 16mA
        ("SlaveSelect_PullUp", UCHAR),    # non-zero to enable pull up
        ("SlaveSelect_PullDown", UCHAR),  # non-zero to enable pull down
        ("SlaveSelect_Drive", UCHAR),     # valid values are 4mA, 8mA, 12mA, 16mA
        ("SlaveSelect_SlowSlew", UCHAR),  # non-zero if slave select pin has slow slew
        ("MISO_Suspend", UCHAR),          # 2 for push-low, 3 for push high, 0 and 1 reserved
        ("SIMO_Suspend", UCHAR),          # 2 for push-low, 3 for push high, 0 and 1 reserved
        ("IO2_IO3_Suspend", UCHAR),       # 2 for push-low, 3 for push high, 0 and 1 reserved
        ("SlaveSelect_Suspend", UCHAR),   # 0 for no-change (not implemented on Rev A), 2 for push-low, 3 for push high, 1 reserved
        # GPIO
        ("GPIO0_Drive", UCHAR),      # valid values are 4mA, 8mA, 12mA, 16mA
        ("GPIO1_Drive", UCHAR),      # valid values are 4mA, 8mA, 12mA, 16mA
        ("GPIO2_Drive", UCHAR),      # valid values are 4mA, 8mA, 12mA, 16mA
        ("GPIO3_Drive", UCHAR),      # valid values are 4mA, 8mA, 12mA, 16mA
        ("GPIO0_SlowSlew", UCHAR),   # non-zero if IO0 pin has slow slew
        ("GPIO1_SlowSlew", UCHAR),   # non-zero if IO0 pin has slow slew
        ("GPIO2_SlowSlew", UCHAR),   # non-zero if IO0 pin has slow slew
        ("GPIO3_SlowSlew", UCHAR),   # non-zero if IO0 pin has slow slew
        ("GPIO0_PullDown", UCHAR),   # non-zero to enable pull down
        ("GPIO1_PullDown", UCHAR),   # non-zero to enable pull down
        ("GPIO2_PullDown", UCHAR),   # non-zero to enable pull down
        ("GPIO3_PullDown", UCHAR),   # non-zero to enable pull down
        ("GPIO0_PullUp", UCHAR),     # non-zero to enable pull up
        ("GPIO1_PullUp", UCHAR),     # non-zero to enable pull up
        ("GPIO2_PullUp", UCHAR),     # non-zero to enable pull up
        ("GPIO3_PullUp", UCHAR),     # non-zero to enable pull up
        ("GPIO0_OpenDrain", UCHAR),  # non-zero to enable open drain
        ("GPIO1_OpenDrain", UCHAR),  # non-zero to enable open drain
        ("GPIO2_OpenDrain", UCHAR),  # non-zero to enable open drain
        ("GPIO3_OpenDrain", UCHAR),  # non-zero to enable open drain
        ("GPIO0_Suspend", UCHAR),    # 0 for no-change, 1 for input (not implemented on Rev A), 2 for push-low, 3 for push high
        ("GPIO1_Suspend", UCHAR),    # 0 for no-change, 1 for input (not implemented on Rev A), 2 for push-low, 3 for push high
        ("GPIO2_Suspend", UCHAR),    # 0 for no-change, 1 for input (not implemented on Rev A), 2 for push-low, 3 for push high
        ("GPIO3_Suspend", UCHAR),    # 0 for no-change, 1 for input (not implemented on Rev A), 2 for push-low, 3 for push high
        ("FallingEdge", UCHAR),      # non-zero to change GPIO on falling edge
        # BCD
        ("BCD_Disable", UCHAR),          # non-zero to disable BCD
        ("BCD_OutputActiveLow", UCHAR),  # non-zero to set BCD output active low
        ("BCD_Drive", UCHAR),            # valid values are 4mA, 8mA, 12mA, 16mA
    ]
PFT_EEPROM_4222H = POINTER(ft_eeprom_4222h)
FT_EEPROM_4222H = ft_eeprom_4222h


# Power Delivery structures for use with FT_EEPROM_Read and FT_EEPROM_Program
# PDO Configuration structure, mA supported values 0 to 10230mA, mV supported values 0 to 51100mV
# This is part of the FT_EEPROM_PD structure.
class ft_eeprom_PD_PDO_mv_ma(Structure):
    _fields_ = [
        ("PDO1ma", USHORT),  # PDO1 mA
        ("PDO1mv", USHORT),  # PDO1 mV
        ("PDO2ma", USHORT),  # PDO2 mA
        ("PDO2mv", USHORT),  # PDO2 mV
        ("PDO3ma", USHORT),  # PDO3 mA
        ("PDO3mv", USHORT),  # PDO3 mV
        ("PDO4ma", USHORT),  # PDO4 mA
        ("PDO4mv", USHORT),  # PDO4 mV
        ("PDO5ma", USHORT),  # PDO5 mA (FTx233HP only)
        ("PDO5mv", USHORT),  # PDO5 mV (FTx233HP only)
        ("PDO6ma", USHORT),  # PDO6 mA (FTx233HP only)
        ("PDO6mv", USHORT),  # PDO6 mV (FTx233HP only)
        ("PDO7ma", USHORT),  # PDO7 mA (FTx233HP only)
        ("PDO7mv", USHORT),  # PDO7 mV (FTx233HP only)
    ]
FT_EEPROM_PD_PDO_mv_ma = ft_eeprom_PD_PDO_mv_ma

# PD EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
# This is appended to the end of the base device structure. e_g.
#     struct {
#         ("base", FT_EEPROM_xxx),
#         ("pd", FT_EEPROM_PD),
#     };
# Device GPIO values are:
#    FTx233HP - 0 to 7, 15 for N/A
#    FTx232HP - 0 to 3, 15 for N/A
class ft_eeprom_pd(Structure):
    _fields_ = [
        # Configuration
        ("srprs", UCHAR),       # non-zero to enable Sink Request Power Role Swap
        ("sraprs", UCHAR),      # non-zero to enable Sink Accept PR Swap
        ("srrprs", UCHAR),      # non-zero to enable Source Request PR SWAP
        ("saprs", UCHAR),       # non-zero to enable Source Accept PR SWAP
        ("vconns", UCHAR),      # non-zero to enable vConn Swap
        ("passthru", UCHAR),    # non-zero to enable Pass Through (FTx233HP only)
        ("extmcu", UCHAR),      # non-zero to enable External MCU
        ("pd2en", UCHAR),       # non-zero to enable PD2 (FTx233HP only)
        ("pd1autoclk", UCHAR),  # non-zero to enable PD1 Auto Clock
        ("pd2autoclk", UCHAR),  # non-zero to enable PD2 Auto Clock (FTx233HP only)
        ("useefuse", UCHAR),    # non-zero to Use EFUSE
        ("extvconn", UCHAR),    # non-zero to enable External vConn

        # GPIO Configuration
        ("count", UCHAR),     # GPIO Count, supported values are 0 to 7
        ("gpio1", UCHAR),     # GPIO Number 1, supports device GPIO values
        ("gpio2", UCHAR),     # GPIO Number 2, supports device GPIO values
        ("gpio3", UCHAR),     # GPIO Number 3, supports device GPIO values
        ("gpio4", UCHAR),     # GPIO Number 4, supports device GPIO values
        ("gpio5", UCHAR),     # GPIO Number 5, supports device GPIO values (FTx233HP only)
        ("gpio6", UCHAR),     # GPIO Number 6, supports device GPIO values (FTx233HP only)
        ("gpio7", UCHAR),     # GPIO Number 7, supports device GPIO values (FTx233HP only)
        ("pd1lden", UCHAR),   # PD1 Load Enable, supports device GPIO values
        ("pd2lden", UCHAR),   # PD2 Load Enable, supports device GPIO values (FTx233HP only)
        ("dispin", UCHAR),    # Discharge Pin, supports device GPIO values
        ("disenbm", UCHAR),   # Discharge Enable BM, 0 for "Drive Hi", 1 for "Drive Low", 2 for "Input Mode", 3 for "Don't Care"
        ("disdisbm", UCHAR),  # Discharge Disable BM, 0 for "Drive Hi", 1 for "Drive Low", 2 for "Input Mode", 3 for "Don't Care"
        ("ccselect", UCHAR),  # CC Select Indicator, supports device GPIO values

        # ISET Configuration
        ("iset1", UCHAR),    # ISET1, supports device GPIO values
        ("iset2", UCHAR),    # ISET2, supports device GPIO values
        ("iset3", UCHAR),    # ISET3, supports device GPIO values
        ("extiset", UCHAR),  # non-zero to enable EXTEND_ISET
        ("isetpd2", UCHAR),  # non-zero to enable ISET_PD2
        ("iseten", UCHAR),   # non-zero to set ISET_ENABLED

        # BM Configuration, 0 for "Drive Hi", 1 for "Drive Low", 2 for "Input Mode", 3 for "Don't Care"
        ("PDO1_GPIO", UCHAR * 7),     # PDO1 GPIO1 to GPIO7
        ("PDO2_GPIO", UCHAR * 7),     # PDO2 GPIO1 to GPIO7
        ("PDO3_GPIO", UCHAR * 7),     # PDO3 GPIO1 to GPIO7
        ("PDO4_GPIO", UCHAR * 7),     # PDO4 GPIO1 to GPIO7
        ("PDO5_GPIO", UCHAR * 7),     # PDO5 GPIO1 to GPIO7 (FTx233HP only)
        ("PDO6_GPIO", UCHAR * 7),     # PDO6 GPIO1 to GPIO7 (FTx233HP only)
        ("PDO7_GPIO", UCHAR * 7),     # PDO7 GPIO1 to GPIO7 (FTx233HP only)
        ("VSET0V_GPIO", UCHAR * 7),   # PDO7 GPIO1 to GPIO7
        ("VSAFE5V_GPIO", UCHAR * 7),  # PDO7 GPIO1 to GPIO7

        ("BM_PDO_Sink", FT_EEPROM_PD_PDO_mv_ma),
        ("BM_PDO_Source", FT_EEPROM_PD_PDO_mv_ma),
        ("BM_PDO_Sink_2", FT_EEPROM_PD_PDO_mv_ma),   # (FTx233HP only)

        # PD Timers
        ("srt", UCHAR),     # Sender Response Timer
        ("hrt", UCHAR),     # Hard Reset Timer
        ("sct", UCHAR),     # Source Capability Timer
        ("dit", UCHAR),     # Discover Identity Timer
        ("srcrt", USHORT),  # Source Recover Timer
        ("trt", USHORT),    # Transition Timer
        ("sofft", USHORT),  # Source off timer
        ("nrt", USHORT),    # No Response Timer
        ("swct", USHORT),   # Sink Wait Capability Timer
        ("snkrt", USHORT),  # Sink Request Timer
        ("dt", UCHAR),      # Discharge Timer
        ("cnst", UCHAR),    # Chunk not supported timer
        ("it", USHORT),     # Idle Timer

        # PD Control
        ("i2caddr", UCHAR),  # I2C Address (hex)
        ("prou", UINT),      # Power Reserved for OWN use
        ("trim1", UINT),     # TRIM1
        ("trim2", UINT),     # TRIM2
        ("extdc", UCHAR),    # non-zero to enable ETERNAL_DC_POWER
    ]
PFT_EEPROM_PD = POINTER(ft_eeprom_pd)
FT_EEPROM_PD = ft_eeprom_pd

# FT2233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
# FT2232H with power delivery
class _ft_eeprom_2233hp(Structure):
    _fields_ = [
        ("ft2232h", FT_EEPROM_2232H),
        ("pd", FT_EEPROM_PD),
    ]
PFT_EEPROM_2233HP = POINTER(_ft_eeprom_2233hp)
FT_EEPROM_2233HP = _ft_eeprom_2233hp

# FT4233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
# FT4232H with power delivery
class _ft_eeprom_4233hp(Structure):
    _fields_ = [
        ("ft4232h", FT_EEPROM_4232H),
        ("pd", FT_EEPROM_PD),
    ]
PFT_EEPROM_4233HP = POINTER(_ft_eeprom_4233hp)
FT_EEPROM_4233HP = _ft_eeprom_4233hp

# FT2232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
# FT2232H with power delivery
class _ft_eeprom_2232hp(Structure):
    _fields_ = [
        ("ft2232h", FT_EEPROM_2232H),
        ("pd", FT_EEPROM_PD),
    ]
PFT_EEPROM_2232HP = POINTER(_ft_eeprom_2232hp)
FT_EEPROM_2232HP = _ft_eeprom_2232hp

# FT4232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
# FT4232H with power delivery
class _ft_eeprom_4232hp(Structure):
    _fields_ = [
        ("ft4232h", FT_EEPROM_4232H),
        ("pd", FT_EEPROM_PD),
    ]
PFT_EEPROM_4232HP = POINTER(_ft_eeprom_4232hp)
FT_EEPROM_4232HP = _ft_eeprom_4232hp

# FT233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
# FT233H with power delivery
class _ft_eeprom_233hp(Structure):
    _fields_ = [
        ("ft232h", FT_EEPROM_232H),
        ("pd", FT_EEPROM_PD),
    ]
PFT_EEPROM_233HP = POINTER(_ft_eeprom_233hp)
FT_EEPROM_233HP = _ft_eeprom_233hp

# FT232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program
# FT232H with power delivery
class _ft_eeprom_232hp(Structure):
    _fields_ = [
        ("ft232h", FT_EEPROM_232H),
        ("pd", FT_EEPROM_PD),
    ]
PFT_EEPROM_232HP = POINTER(_ft_eeprom_232hp)
FT_EEPROM_232HP = _ft_eeprom_232hp

FT_EEPROM_Read = _libraries["ftd2xx.dll"].FT_EEPROM_Read
FT_EEPROM_Read.restype = FT_STATUS
FT_EEPROM_Read.argtypes = [FT_HANDLE, c_void_p, DWORD, c_char_p, c_char_p, c_char_p, c_char_p]
FT_EEPROM_Read.__doc__ = """FT_STATUS FT_EEPROM_Read(FT_HANDLE ftHandle, void *eepromData, DWORD eepromDataSize, char * Manufacturer, char * ManufacturerId, char * Description, char * SerialNumber)
"""

FT_EEPROM_Program = _libraries["ftd2xx.dll"].FT_EEPROM_Program
FT_EEPROM_Program.restype = FT_STATUS
FT_EEPROM_Program.argtypes = [FT_HANDLE, c_void_p, DWORD, c_char_p, c_char_p, c_char_p, c_char_p]
FT_EEPROM_Program.__doc__ = """FT_STATUS FT_EEPROM_Program(FT_HANDLE ftHandle, void *eepromData, DWORD eepromDataSize, char * Manufacturer, char * ManufacturerId, char * Description, char * SerialNumber)
"""

# ftd2xx.h 554
FT_SetLatencyTimer = _libraries["ftd2xx.dll"].FT_SetLatencyTimer
FT_SetLatencyTimer.restype = FT_STATUS
# FT_SetLatencyTimer(ftHandle, ucLatency)
FT_SetLatencyTimer.argtypes = [FT_HANDLE, UCHAR]
FT_SetLatencyTimer.__doc__ = """FT_STATUS FT_SetLatencyTimer(FT_HANDLE ftHandle, UCHAR ucLatency)
ftd2xx.h:554"""
# ftd2xx.h 560
FT_GetLatencyTimer = _libraries["ftd2xx.dll"].FT_GetLatencyTimer
FT_GetLatencyTimer.restype = FT_STATUS
# FT_GetLatencyTimer(ftHandle, pucLatency)
FT_GetLatencyTimer.argtypes = [FT_HANDLE, PUCHAR]
FT_GetLatencyTimer.__doc__ = """FT_STATUS FT_GetLatencyTimer(FT_HANDLE ftHandle, PUCHAR pucLatency)
ftd2xx.h:560"""
# ftd2xx.h 567
FT_SetBitMode = _libraries["ftd2xx.dll"].FT_SetBitMode
FT_SetBitMode.restype = FT_STATUS
# FT_SetBitMode(ftHandle, ucMask, ucEnable)
FT_SetBitMode.argtypes = [FT_HANDLE, UCHAR, UCHAR]
FT_SetBitMode.__doc__ = """FT_STATUS FT_SetBitMode(FT_HANDLE ftHandle, UCHAR ucMask, UCHAR ucEnable)
ftd2xx.h:567"""
# ftd2xx.h 573
FT_GetBitMode = _libraries["ftd2xx.dll"].FT_GetBitMode
FT_GetBitMode.restype = FT_STATUS
# FT_GetBitMode(ftHandle, pucMode)
FT_GetBitMode.argtypes = [FT_HANDLE, PUCHAR]
FT_GetBitMode.__doc__ = """FT_STATUS FT_GetBitMode(FT_HANDLE ftHandle, PUCHAR pucMode)
ftd2xx.h:573"""
# ftd2xx.h 580
FT_SetUSBParameters = _libraries["ftd2xx.dll"].FT_SetUSBParameters
FT_SetUSBParameters.restype = FT_STATUS
# FT_SetUSBParameters(ftHandle, ulInTransferSize, ulOutTransferSize)
FT_SetUSBParameters.argtypes = [FT_HANDLE, ULONG, ULONG]
FT_SetUSBParameters.__doc__ = """FT_STATUS FT_SetUSBParameters(FT_HANDLE ftHandle, ULONG ulInTransferSize, ULONG ulOutTransferSize)
ftd2xx.h:580"""
# ftd2xx.h 586
FT_SetDeadmanTimeout = _libraries["ftd2xx.dll"].FT_SetDeadmanTimeout
FT_SetDeadmanTimeout.restype = FT_STATUS
# FT_SetDeadmanTimeout(ftHandle, ulDeadmanTimeout)
FT_SetDeadmanTimeout.argtypes = [FT_HANDLE, ULONG]
FT_SetDeadmanTimeout.__doc__ = """FT_STATUS FT_SetDeadmanTimeout(FT_HANDLE ftHandle, ULONG ulDeadmanTimeout)
ftd2xx.h:586"""
# ftd2xx.h 596
FT_GetDeviceInfo = _libraries["ftd2xx.dll"].FT_GetDeviceInfo
FT_GetDeviceInfo.restype = FT_STATUS
# FT_GetDeviceInfo(ftHandle, lpftDevice, lpdwID, SerialNumber, Description, Dummy)
FT_GetDeviceInfo.argtypes = [
    FT_HANDLE,
    POINTER(FT_DEVICE),
    LPDWORD,
    PCHAR,
    PCHAR,
    LPVOID,
]
FT_GetDeviceInfo.__doc__ = """FT_STATUS FT_GetDeviceInfo(FT_HANDLE ftHandle, FT_DEVICE * lpftDevice, LPDWORD lpdwID, PCHAR SerialNumber, PCHAR Description, LPVOID Dummy)
ftd2xx.h:596"""
# ftd2xx.h 601
FT_StopInTask = _libraries["ftd2xx.dll"].FT_StopInTask
FT_StopInTask.restype = FT_STATUS
# FT_StopInTask(ftHandle)
FT_StopInTask.argtypes = [FT_HANDLE]
FT_StopInTask.__doc__ = """FT_STATUS FT_StopInTask(FT_HANDLE ftHandle)
ftd2xx.h:601"""
# ftd2xx.h 606
FT_RestartInTask = _libraries["ftd2xx.dll"].FT_RestartInTask
FT_RestartInTask.restype = FT_STATUS
# FT_RestartInTask(ftHandle)
FT_RestartInTask.argtypes = [FT_HANDLE]
FT_RestartInTask.__doc__ = """FT_STATUS FT_RestartInTask(FT_HANDLE ftHandle)
ftd2xx.h:606"""
# ftd2xx.h 612
FT_SetResetPipeRetryCount = _libraries["ftd2xx.dll"].FT_SetResetPipeRetryCount
FT_SetResetPipeRetryCount.restype = FT_STATUS
# FT_SetResetPipeRetryCount(ftHandle, dwCount)
FT_SetResetPipeRetryCount.argtypes = [FT_HANDLE, DWORD]
FT_SetResetPipeRetryCount.__doc__ = """FT_STATUS FT_SetResetPipeRetryCount(FT_HANDLE ftHandle, DWORD dwCount)
ftd2xx.h:612"""
# ftd2xx.h 617
FT_ResetPort = _libraries["ftd2xx.dll"].FT_ResetPort
FT_ResetPort.restype = FT_STATUS
# FT_ResetPort(ftHandle)
FT_ResetPort.argtypes = [FT_HANDLE]
FT_ResetPort.__doc__ = """FT_STATUS FT_ResetPort(FT_HANDLE ftHandle)
ftd2xx.h:617"""
# ftd2xx.h 622
FT_CyclePort = _libraries["ftd2xx.dll"].FT_CyclePort
FT_CyclePort.restype = FT_STATUS
# FT_CyclePort(ftHandle)
FT_CyclePort.argtypes = [FT_HANDLE]
FT_CyclePort.__doc__ = """FT_STATUS FT_CyclePort(FT_HANDLE ftHandle)
ftd2xx.h:622"""
# ftd2xx.h 638
FT_W32_CreateFile = _libraries["ftd2xx.dll"].FT_W32_CreateFile
FT_W32_CreateFile.restype = FT_HANDLE
# FT_W32_CreateFile(lpszName, dwAccess, dwShareMode, lpSecurityAttributes, dwCreate, dwAttrsAndFlags, hTemplate)
FT_W32_CreateFile.argtypes = [
    LPCSTR,
    DWORD,
    DWORD,
    LPSECURITY_ATTRIBUTES,
    DWORD,
    DWORD,
    HANDLE,
]
FT_W32_CreateFile.__doc__ = """FT_HANDLE FT_W32_CreateFile(LPCSTR lpszName, DWORD dwAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreate, DWORD dwAttrsAndFlags, HANDLE hTemplate)
ftd2xx.h:638"""
# ftd2xx.h 643
FT_W32_CloseHandle = _libraries["ftd2xx.dll"].FT_W32_CloseHandle
FT_W32_CloseHandle.restype = BOOL
# FT_W32_CloseHandle(ftHandle)
FT_W32_CloseHandle.argtypes = [FT_HANDLE]
FT_W32_CloseHandle.__doc__ = """BOOL FT_W32_CloseHandle(FT_HANDLE ftHandle)
ftd2xx.h:643"""
# ftd2xx.h 652
FT_W32_ReadFile = _libraries["ftd2xx.dll"].FT_W32_ReadFile
FT_W32_ReadFile.restype = BOOL
# FT_W32_ReadFile(ftHandle, lpBuffer, nBufferSize, lpBytesReturned, lpOverlapped)
FT_W32_ReadFile.argtypes = [FT_HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED]
FT_W32_ReadFile.__doc__ = """BOOL FT_W32_ReadFile(FT_HANDLE ftHandle, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
ftd2xx.h:652"""
# ftd2xx.h 661
FT_W32_WriteFile = _libraries["ftd2xx.dll"].FT_W32_WriteFile
FT_W32_WriteFile.restype = BOOL
# FT_W32_WriteFile(ftHandle, lpBuffer, nBufferSize, lpBytesWritten, lpOverlapped)
FT_W32_WriteFile.argtypes = [FT_HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED]
FT_W32_WriteFile.__doc__ = """BOOL FT_W32_WriteFile(FT_HANDLE ftHandle, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesWritten, LPOVERLAPPED lpOverlapped)
ftd2xx.h:661"""
# ftd2xx.h 666
FT_W32_GetLastError = _libraries["ftd2xx.dll"].FT_W32_GetLastError
FT_W32_GetLastError.restype = DWORD
# FT_W32_GetLastError(ftHandle)
FT_W32_GetLastError.argtypes = [FT_HANDLE]
FT_W32_GetLastError.__doc__ = """DWORD FT_W32_GetLastError(FT_HANDLE ftHandle)
ftd2xx.h:666"""
# ftd2xx.h 674
FT_W32_GetOverlappedResult = _libraries["ftd2xx.dll"].FT_W32_GetOverlappedResult
FT_W32_GetOverlappedResult.restype = BOOL
# FT_W32_GetOverlappedResult(ftHandle, lpOverlapped, lpdwBytesTransferred, bWait)
FT_W32_GetOverlappedResult.argtypes = [FT_HANDLE, LPOVERLAPPED, LPDWORD, BOOL]
FT_W32_GetOverlappedResult.__doc__ = """BOOL FT_W32_GetOverlappedResult(FT_HANDLE ftHandle, LPOVERLAPPED lpOverlapped, LPDWORD lpdwBytesTransferred, BOOL bWait)
ftd2xx.h:674"""
# ftd2xx.h 679
FT_W32_CancelIo = _libraries["ftd2xx.dll"].FT_W32_CancelIo
FT_W32_CancelIo.restype = BOOL
# FT_W32_CancelIo(ftHandle)
FT_W32_CancelIo.argtypes = [FT_HANDLE]
FT_W32_CancelIo.__doc__ = """BOOL FT_W32_CancelIo(FT_HANDLE ftHandle)
ftd2xx.h:679"""
# ftd2xx.h 685


class _FTCOMSTAT(Structure):
    _fields_ = [
        # ftd2xx.h 685
        ("fCtsHold", DWORD, 1),
        ("fDsrHold", DWORD, 1),
        ("fRlsdHold", DWORD, 1),
        ("fXoffHold", DWORD, 1),
        ("fXoffSent", DWORD, 1),
        ("fEof", DWORD, 1),
        ("fTxim", DWORD, 1),
        ("fReserved", DWORD, 25),
        ("cbInQue", DWORD),
        ("cbOutQue", DWORD),
    ]


LPFTCOMSTAT = POINTER(_FTCOMSTAT)
FTCOMSTAT = _FTCOMSTAT
# ftd2xx.h 698


class _FTDCB(Structure):
    _fields_ = [
        # ftd2xx.h 698
        ("DCBlength", DWORD),
        ("BaudRate", DWORD),
        ("fBinary", DWORD, 1),
        ("fParity", DWORD, 1),
        ("fOutxCtsFlow", DWORD, 1),
        ("fOutxDsrFlow", DWORD, 1),
        ("fDtrControl", DWORD, 2),
        ("fDsrSensitivity", DWORD, 1),
        ("fTXContinueOnXoff", DWORD, 1),
        ("fOutX", DWORD, 1),
        ("fInX", DWORD, 1),
        ("fErrorChar", DWORD, 1),
        ("fNull", DWORD, 1),
        ("fRtsControl", DWORD, 2),
        ("fAbortOnError", DWORD, 1),
        ("fDummy2", DWORD, 17),
        ("wReserved", WORD),
        ("XonLim", WORD),
        ("XoffLim", WORD),
        ("ByteSize", BYTE),
        ("Parity", BYTE),
        ("StopBits", BYTE),
        ("XonChar", c_char),
        ("XoffChar", c_char),
        ("ErrorChar", c_char),
        ("EofChar", c_char),
        ("EvtChar", c_char),
        ("wReserved1", WORD),
    ]


FTDCB = _FTDCB
LPFTDCB = POINTER(_FTDCB)
# ftd2xx.h 729


class _FTTIMEOUTS(Structure):
    _fields_ = [
        # ftd2xx.h 729
        ("ReadIntervalTimeout", DWORD),
        ("ReadTotalTimeoutMultiplier", DWORD),
        ("ReadTotalTimeoutConstant", DWORD),
        ("WriteTotalTimeoutMultiplier", DWORD),
        ("WriteTotalTimeoutConstant", DWORD),
    ]


FTTIMEOUTS = _FTTIMEOUTS
LPFTTIMEOUTS = POINTER(_FTTIMEOUTS)
# ftd2xx.h 741
FT_W32_ClearCommBreak = _libraries["ftd2xx.dll"].FT_W32_ClearCommBreak
FT_W32_ClearCommBreak.restype = BOOL
# FT_W32_ClearCommBreak(ftHandle)
FT_W32_ClearCommBreak.argtypes = [FT_HANDLE]
FT_W32_ClearCommBreak.__doc__ = """BOOL FT_W32_ClearCommBreak(FT_HANDLE ftHandle)
ftd2xx.h:741"""
# ftd2xx.h 748
FT_W32_ClearCommError = _libraries["ftd2xx.dll"].FT_W32_ClearCommError
FT_W32_ClearCommError.restype = BOOL
# FT_W32_ClearCommError(ftHandle, lpdwErrors, lpftComstat)
FT_W32_ClearCommError.argtypes = [FT_HANDLE, LPDWORD, LPFTCOMSTAT]
FT_W32_ClearCommError.__doc__ = """BOOL FT_W32_ClearCommError(FT_HANDLE ftHandle, LPDWORD lpdwErrors, LPFTCOMSTAT lpftComstat)
ftd2xx.h:748"""
# ftd2xx.h 754
FT_W32_EscapeCommFunction = _libraries["ftd2xx.dll"].FT_W32_EscapeCommFunction
FT_W32_EscapeCommFunction.restype = BOOL
# FT_W32_EscapeCommFunction(ftHandle, dwFunc)
FT_W32_EscapeCommFunction.argtypes = [FT_HANDLE, DWORD]
FT_W32_EscapeCommFunction.__doc__ = """BOOL FT_W32_EscapeCommFunction(FT_HANDLE ftHandle, DWORD dwFunc)
ftd2xx.h:754"""
# ftd2xx.h 760
FT_W32_GetCommModemStatus = _libraries["ftd2xx.dll"].FT_W32_GetCommModemStatus
FT_W32_GetCommModemStatus.restype = BOOL
# FT_W32_GetCommModemStatus(ftHandle, lpdwModemStatus)
FT_W32_GetCommModemStatus.argtypes = [FT_HANDLE, LPDWORD]
FT_W32_GetCommModemStatus.__doc__ = """BOOL FT_W32_GetCommModemStatus(FT_HANDLE ftHandle, LPDWORD lpdwModemStatus)
ftd2xx.h:760"""
# ftd2xx.h 766
FT_W32_GetCommState = _libraries["ftd2xx.dll"].FT_W32_GetCommState
FT_W32_GetCommState.restype = BOOL
# FT_W32_GetCommState(ftHandle, lpftDcb)
FT_W32_GetCommState.argtypes = [FT_HANDLE, LPFTDCB]
FT_W32_GetCommState.__doc__ = """BOOL FT_W32_GetCommState(FT_HANDLE ftHandle, LPFTDCB lpftDcb)
ftd2xx.h:766"""
# ftd2xx.h 772
FT_W32_GetCommTimeouts = _libraries["ftd2xx.dll"].FT_W32_GetCommTimeouts
FT_W32_GetCommTimeouts.restype = BOOL
# FT_W32_GetCommTimeouts(ftHandle, pTimeouts)
FT_W32_GetCommTimeouts.argtypes = [FT_HANDLE, POINTER(FTTIMEOUTS)]
FT_W32_GetCommTimeouts.__doc__ = """BOOL FT_W32_GetCommTimeouts(FT_HANDLE ftHandle, FTTIMEOUTS * pTimeouts)
ftd2xx.h:772"""
# ftd2xx.h 778
FT_W32_PurgeComm = _libraries["ftd2xx.dll"].FT_W32_PurgeComm
FT_W32_PurgeComm.restype = BOOL
# FT_W32_PurgeComm(ftHandle, dwMask)
FT_W32_PurgeComm.argtypes = [FT_HANDLE, DWORD]
FT_W32_PurgeComm.__doc__ = """BOOL FT_W32_PurgeComm(FT_HANDLE ftHandle, DWORD dwMask)
ftd2xx.h:778"""
# ftd2xx.h 783
FT_W32_SetCommBreak = _libraries["ftd2xx.dll"].FT_W32_SetCommBreak
FT_W32_SetCommBreak.restype = BOOL
# FT_W32_SetCommBreak(ftHandle)
FT_W32_SetCommBreak.argtypes = [FT_HANDLE]
FT_W32_SetCommBreak.__doc__ = """BOOL FT_W32_SetCommBreak(FT_HANDLE ftHandle)
ftd2xx.h:783"""
# ftd2xx.h 789
FT_W32_SetCommMask = _libraries["ftd2xx.dll"].FT_W32_SetCommMask
FT_W32_SetCommMask.restype = BOOL
# FT_W32_SetCommMask(ftHandle, ulEventMask)
FT_W32_SetCommMask.argtypes = [FT_HANDLE, ULONG]
FT_W32_SetCommMask.__doc__ = """BOOL FT_W32_SetCommMask(FT_HANDLE ftHandle, ULONG ulEventMask)
ftd2xx.h:789"""
# ftd2xx.h 795
FT_W32_SetCommState = _libraries["ftd2xx.dll"].FT_W32_SetCommState
FT_W32_SetCommState.restype = BOOL
# FT_W32_SetCommState(ftHandle, lpftDcb)
FT_W32_SetCommState.argtypes = [FT_HANDLE, LPFTDCB]
FT_W32_SetCommState.__doc__ = """BOOL FT_W32_SetCommState(FT_HANDLE ftHandle, LPFTDCB lpftDcb)
ftd2xx.h:795"""
# ftd2xx.h 801
FT_W32_SetCommTimeouts = _libraries["ftd2xx.dll"].FT_W32_SetCommTimeouts
FT_W32_SetCommTimeouts.restype = BOOL
# FT_W32_SetCommTimeouts(ftHandle, pTimeouts)
FT_W32_SetCommTimeouts.argtypes = [FT_HANDLE, POINTER(FTTIMEOUTS)]
FT_W32_SetCommTimeouts.__doc__ = """BOOL FT_W32_SetCommTimeouts(FT_HANDLE ftHandle, FTTIMEOUTS * pTimeouts)
ftd2xx.h:801"""
# ftd2xx.h 808
FT_W32_SetupComm = _libraries["ftd2xx.dll"].FT_W32_SetupComm
FT_W32_SetupComm.restype = BOOL
# FT_W32_SetupComm(ftHandle, dwReadBufferSize, dwWriteBufferSize)
FT_W32_SetupComm.argtypes = [FT_HANDLE, DWORD, DWORD]
FT_W32_SetupComm.__doc__ = """BOOL FT_W32_SetupComm(FT_HANDLE ftHandle, DWORD dwReadBufferSize, DWORD dwWriteBufferSize)
ftd2xx.h:808"""
# ftd2xx.h 815
FT_W32_WaitCommEvent = _libraries["ftd2xx.dll"].FT_W32_WaitCommEvent
FT_W32_WaitCommEvent.restype = BOOL
# FT_W32_WaitCommEvent(ftHandle, pulEvent, lpOverlapped)
FT_W32_WaitCommEvent.argtypes = [FT_HANDLE, PULONG, LPOVERLAPPED]
FT_W32_WaitCommEvent.__doc__ = """BOOL FT_W32_WaitCommEvent(FT_HANDLE ftHandle, PULONG pulEvent, LPOVERLAPPED lpOverlapped)
ftd2xx.h:815"""
# ftd2xx.h 822


class _ft_device_list_info_node(Structure):
    _fields_ = [
        # ftd2xx.h 822
        ("Flags", ULONG),
        ("Type", ULONG),
        ("ID", ULONG),
        ("LocId", DWORD),
        ("SerialNumber", c_char * 16),
        ("Description", c_char * 64),
        ("ftHandle", FT_HANDLE),
    ]


FT_DEVICE_LIST_INFO_NODE = _ft_device_list_info_node
# ftd2xx.h 836
FT_CreateDeviceInfoList = _libraries["ftd2xx.dll"].FT_CreateDeviceInfoList
FT_CreateDeviceInfoList.restype = FT_STATUS
# FT_CreateDeviceInfoList(lpdwNumDevs)
FT_CreateDeviceInfoList.argtypes = [LPDWORD]
FT_CreateDeviceInfoList.__doc__ = """FT_STATUS FT_CreateDeviceInfoList(LPDWORD lpdwNumDevs)
ftd2xx.h:836"""
# ftd2xx.h 842
FT_GetDeviceInfoList = _libraries["ftd2xx.dll"].FT_GetDeviceInfoList
FT_GetDeviceInfoList.restype = FT_STATUS
# FT_GetDeviceInfoList(pDest, lpdwNumDevs)
FT_GetDeviceInfoList.argtypes = [POINTER(FT_DEVICE_LIST_INFO_NODE), LPDWORD]
FT_GetDeviceInfoList.__doc__ = """FT_STATUS FT_GetDeviceInfoList(FT_DEVICE_LIST_INFO_NODE * pDest, LPDWORD lpdwNumDevs)
ftd2xx.h:842"""
# ftd2xx.h 854
FT_GetDeviceInfoDetail = _libraries["ftd2xx.dll"].FT_GetDeviceInfoDetail
FT_GetDeviceInfoDetail.restype = FT_STATUS
# FT_GetDeviceInfoDetail(dwIndex, lpdwFlags, lpdwType, lpdwID, lpdwLocId, lpSerialNumber, lpDescription, pftHandle)
FT_GetDeviceInfoDetail.argtypes = [
    DWORD,
    LPDWORD,
    LPDWORD,
    LPDWORD,
    LPDWORD,
    LPVOID,
    LPVOID,
    POINTER(FT_HANDLE),
]
FT_GetDeviceInfoDetail.__doc__ = """FT_STATUS FT_GetDeviceInfoDetail(DWORD dwIndex, LPDWORD lpdwFlags, LPDWORD lpdwType, LPDWORD lpdwID, LPDWORD lpdwLocId, LPVOID lpSerialNumber, LPVOID lpDescription, FT_HANDLE * pftHandle)
ftd2xx.h:854"""
# ftd2xx.h 865
FT_GetDriverVersion = _libraries["ftd2xx.dll"].FT_GetDriverVersion
FT_GetDriverVersion.restype = FT_STATUS
# FT_GetDriverVersion(ftHandle, lpdwVersion)
FT_GetDriverVersion.argtypes = [FT_HANDLE, LPDWORD]
FT_GetDriverVersion.__doc__ = """FT_STATUS FT_GetDriverVersion(FT_HANDLE ftHandle, LPDWORD lpdwVersion)
ftd2xx.h:865"""
# ftd2xx.h 870
FT_GetLibraryVersion = _libraries["ftd2xx.dll"].FT_GetLibraryVersion
FT_GetLibraryVersion.restype = FT_STATUS
# FT_GetLibraryVersion(lpdwVersion)
FT_GetLibraryVersion.argtypes = [LPDWORD]
FT_GetLibraryVersion.__doc__ = """FT_STATUS FT_GetLibraryVersion(LPDWORD lpdwVersion)
ftd2xx.h:870"""
# ftd2xx.h 899
FT_GetComPortNumber = _libraries["ftd2xx.dll"].FT_GetComPortNumber
FT_GetComPortNumber.restype = FT_STATUS
# FT_GetComPortNumber(ftHandle, lpdwComPortNumber)
FT_GetComPortNumber.argtypes = [FT_HANDLE, LPLONG]
FT_GetComPortNumber.__doc__ = """FT_STATUS FT_GetComPortNumber(FT_HANDLE ftHandle, LPLONG lpdwComPortNumber)
ftd2xx.h:899"""

__all__ = [
    # "FT_SetVIDPID",  # Linux/Darwin only
    # "FT_GetVIDPID",  # Linux/Darwin only
    "FT_CreateDeviceInfoList",
    "FT_GetDeviceInfoList",
    "FT_GetDeviceInfoDetail",
    "FT_ListDevices",
    "FT_Open",
    "FT_OpenEx",
    "FT_Close",
    "FT_Read",
    "FT_Write",
    "FT_SetBaudRate",
    "FT_SetDivisor",
    "FT_SetDataCharacteristics",
    "FT_SetTimeouts",
    "FT_SetFlowControl",
    "FT_SetDtr",
    "FT_ClrDtr",
    "FT_SetRts",
    "FT_ClrRts",
    "FT_GetModemStatus",
    "FT_GetQueueStatus",
    "FT_GetDeviceInfo",
    "FT_GetDriverVersion",  # Windows only
    "FT_GetLibraryVersion",  # Windows only
    "FT_GetComPortNumber",  # Windows only
    "FT_GetStatus",
    "FT_SetEventNotification",
    "FT_SetChars",
    "FT_SetBreakOn",
    "FT_SetBreakOff",
    "FT_Purge",
    "FT_ResetDevice",
    "FT_ResetPort",  # Windows only
    "FT_CyclePort",  # Windows only
    # "FT_Rescan", # Windows only, not implimented yet
    # "FT_Reload",  # Windows only, not implimented yet
    "FT_SetResetPipeRetryCount",  # Windows only
    "FT_StopInTask",
    "FT_RestartInTask",
    "FT_SetDeadmanTimeout",
    "FT_IoCtl",  # Undocumented
    "FT_SetWaitMask",  # Undocumented
    "FT_WaitOnMask",  # Undocumented
    "FT_ReadEE",
    "FT_WriteEE",
    "FT_EraseEE",
    "FT_EE_Read",
    "FT_EE_ReadEx",
    "FT_EE_Program",
    "FT_EE_ProgramEx",
    "FT_EE_UASize",
    "FT_EE_UARead",
    "FT_EE_UAWrite",
    "FT_EEPROM_Read",  # Windows XP or later,
    "FT_EEPROM_Program",  # Windows XP or later,
]

# Extended API (does not apply to FT8U232AM or FT8U245AM devices)
__all__ += [
    "FT_SetLatencyTimer",
    "FT_GetLatencyTimer",
    "FT_SetBitMode",
    "FT_GetBitMode",
    "FT_SetUSBParameters",
]

# Win32 API (cross-platform)
__all__ += [
    "FT_W32_CreateFile",
    "FT_W32_CloseHandle",
    "FT_W32_ReadFile",
    "FT_W32_WriteFile",
    "FT_W32_GetOverlappedResult",
    "FT_W32_EscapeCommFunction",
    "FT_W32_GetCommModemStatus",
    "FT_W32_SetupComm",
    "FT_W32_SetCommState",
    "FT_W32_GetCommState",
    "FT_W32_SetCommTimeouts",
    "FT_W32_GetCommTimeouts",
    "FT_W32_SetCommBreak",
    "FT_W32_ClearCommBreak",
    "FT_W32_SetCommMask",
    # "FT_W32_GetCommMask",  # Not implimented yet
    "FT_W32_WaitCommEvent",
    "FT_W32_PurgeComm",
    "FT_W32_GetLastError",
    "FT_W32_ClearCommError",
]

# Data types
__all__ += [
    "FT_HANDLE",
    "ft_program_data",
    "ft_eeprom_header",
    "ft_eeprom_232b",
    "ft_eeprom_2232",
    "ft_eeprom_232r",
    "ft_eeprom_2232h",
    "ft_eeprom_4232h",
    "ft_eeprom_232h",
    "ft_eeprom_x_series",
    "ft_eeprom_4222h",
    "ft_eeprom_PD_PDO_mv_ma",
    "ft_eeprom_pd",
    "_ft_eeprom_2233hp",
    "_ft_eeprom_4233hp",
    "_ft_eeprom_2232hp",
    "_ft_eeprom_4232hp",
    "_ft_eeprom_233hp",
    "_ft_eeprom_232hp",
    "BOOL",
    "BYTE",
    "DWORD",
    "HANDLE",
    "LPCSTR",
    "ULONG",
    "WORD",
    "USHORT",
    "PCHAR",
    "LPWORD",
    "PULONG",
    "LPVOID",
    "STRING",
    "UCHAR",
    "CHAR",
    "UINT",
    "PUCHAR",
    "PVOID",
    "LPTSTR",
    "LPDWORD",
    "VOID",
    "ULONGLONG",
]

# What are these?
__all__ += [
    "FT_W32_CancelIo",
    "FT_GetEventStatus",
]
